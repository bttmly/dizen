// Generated by CoffeeScript 1.8.0
var NO_COPY, actual_decorate, decorate, decorate_base, decorator_defaults, dizen_base, do_init, flip_decorate, get_decorators, is_pojo, make_composite_decorator, make_decorator, merge, noop, registry, sequence, set_cleanup, use, validate_decorator,
  __slice = [].slice,
  __hasProp = {}.hasOwnProperty;

NO_COPY = {
  "decorator_name": 1,
  "init": 1,
  "cleanup": 1,
  "can_overwrite": 1,
  "bind_methods": 1
};

decorate_base = {
  cleanup: function() {},
  decorate: function(dec, opt) {
    return decorate(this, dec, opt);
  }
};

noop = function() {};

merge = function() {
  var key, source, sources, target, val, _i, _len;
  target = arguments[0], sources = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  for (_i = 0, _len = sources.length; _i < _len; _i++) {
    source = sources[_i];
    for (key in source) {
      if (!__hasProp.call(source, key)) continue;
      val = source[key];
      target[key] = val;
    }
  }
  return target;
};

decorator_defaults = function() {
  return {
    can_overwrite: true,
    bind_methods: false
  };
};

is_pojo = (function() {
  var gpo, obj_proto;
  gpo = Object.getPrototypeOf;
  obj_proto = Object.prototype;
  return function(obj) {
    return obj_proto === gpo(obj);
  };
})();

registry = {};

use = function(dec) {
  validate_decorator(dec);
  if (registry[dec.decorator_name]) {
    throw new Error("Decorator already registered as " + dec.decorator_name);
  }
  return registry[dec.decorator_name] = dec;
};

validate_decorator = function(dec) {
  if (typeof dec.decorator_name !== "string") {
    throw new Error("Decorators must have a valid `decorator_name` property.");
  }
};

dizen_base = function(obj) {
  if (obj == null) {
    obj = {};
  }
  return obj.cleanup || (obj.cleanup = noop);
};

actual_decorate = function(obj, dec) {
  var bind_all, can_overwrite, key, val;
  merge(decorator_defaults(), dec);
  bind_all = dec.bind_all, can_overwrite = dec.can_overwrite;
  for (key in dec) {
    if (!__hasProp.call(dec, key)) continue;
    val = dec[key];
    if (NO_COPY[key]) {
      continue;
    }
    if (!(can_overwrite || (obj[key] == null))) {
      throw new Error("Refusing to overwrite " + key);
    }
    obj[key] = bind_all && typeof val === "function" ? val.bind(obj) : val;
  }
  return obj;
};

set_cleanup = function(obj, dec) {
  var cleanup;
  if (typeof dec.cleanup === "function") {
    cleanup = obj.cleanup;
    return obj.cleanup = function() {
      cleanup();
      return dec.cleanup.call(obj);
    };
  }
};

do_init = function(obj, dec, opt) {
  if (typeof dec.init === "function") {
    return dec.init.call(obj, opt);
  }
};

get_decorators = function(dec) {
  var decs, _i, _len;
  if (Array.isArray(dec)) {
    decs = dec.map(function(str) {
      if (typeof str === "string") {
        return str;
      } else {
        return registry[str];
      }
    });
  } else if (typeof dec === "string") {
    decs = [registry[dec]];
  } else {
    decs = [dec];
  }
  for (_i = 0, _len = decs.length; _i < _len; _i++) {
    dec = decs[_i];
    validate_decorator(dec);
  }
  return decs;
};

decorate = function(obj, dec, opt) {
  var d, _i, _len, _ref;
  if (opt == null) {
    opt = {};
  }
  _ref = get_decorators(dec);
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    d = _ref[_i];
    dizen_base(obj);
    actual_decorate(obj, d);
    set_cleanup(obj, d);
    do_init(obj, d, opt);
  }
  return obj;
};

flip_decorate = function(dec, opt, obj) {
  return decorate(dec, obj, opt);
};

sequence = function(decs) {
  return function(obj, opt) {};
};

make_decorator = function(dec) {
  return function(obj, opt) {
    dizen_base(obj);
    actual_decorate(obj, dec);
    set_cleanup(obj, dec);
    return do_init(obj, dec, opt);
  };
};

make_composite_decorator = function() {
  var decs;
  decs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  if (Array.isArray(arguments[0])) {
    decs = arguments[0];
  }
  decs = decs.map(make_decorator);
  return function(obj, opt) {
    var dec, _i, _len;
    for (_i = 0, _len = decs.length; _i < _len; _i++) {
      dec = decs[_i];
      dec(obj, opt);
    }
    return obj;
  };
};

module.exports = {
  decorate: decorate,
  flip_decorate: flip_decorate,
  use: use
};
