// Generated by CoffeeScript 1.8.0
var NO_COPY, actual_merge, decorate, decorator_defaults, dizen, dizen_base, do_init, flip_decorate, get_decorators, is_nil, is_pojo, merge, noop, registry, set_cleanup, use, validate_decorator,
  __slice = [].slice,
  __hasProp = {}.hasOwnProperty;

NO_COPY = {
  "decorator_name": 1,
  "init": 1,
  "cleanup": 1,
  "no_overwrite": 1,
  "bind_methods": 1
};


/*
decorator_name: String
bind_all: Boolean
init: Function
cleanup: Function
 */

merge = function() {
  var key, source, sources, target, val, _i, _len;
  target = arguments[0], sources = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  for (_i = 0, _len = sources.length; _i < _len; _i++) {
    source = sources[_i];
    for (key in source) {
      if (!__hasProp.call(source, key)) continue;
      val = source[key];
      target[key] = val;
    }
  }
  return target;
};

decorator_defaults = function() {
  return {
    no_overwrite: true,
    bind_methods: false
  };
};

is_pojo = (function() {
  var gpo, obj_proto;
  gpo = Object.getPrototypeOf;
  obj_proto = Object.prototype;
  return function(obj) {
    return obj_proto === gpo(obj);
  };
})();

is_nil = function(obj) {
  return obj === null || obj === void 0;
};

noop = function() {};

dizen = function(obj) {};

registry = {};

use = function(dec) {
  if (typeof dec.decorator_name !== "string") {
    throw new Error();
  }
  if (registry[dec.decorator_name]) {
    throw new Error();
  }
};

validate_decorator = function(dec) {
  if (typeof dec.decorator_name !== "string") {
    throw new Error("Bedizen decorators must have a valid `decorator_name` property.");
  }
};

dizen_base = function(obj) {
  return obj.cleanup || (obj.cleanup = noop);
};

actual_merge = function(obj, dec) {
  var bind_all, key, no_overwrite, val;
  merge(decorator_defaults(), dec);
  bind_all = dec.bind_all, no_overwrite = dec.no_overwrite;
  for (key in dec) {
    if (!__hasProp.call(dec, key)) continue;
    val = dec[key];
    if (NO_COPY[key]) {
      continue;
    }
    if ((obj[key] != null) && no_overwrite) {
      continue;
    }
    obj[key] = bind_all && typeof val === "function" ? val.bind(obj) : val;
  }
  return obj;
};

set_cleanup = function(obj, dec) {
  var cleanup;
  if (typeof dec.cleanup === "function") {
    cleanup = obj.cleanup;
    return obj.cleanup = function() {
      cleanup();
      return dec.cleanup.call(obj);
    };
  }
};

do_init = function(obj, dec, opt) {
  if (typeof dec.init === "function") {
    return dec.init.call(obj, opt);
  }
};

get_decorators = function(dec) {
  var decs, _i, _len;
  if (Array.isArray(dec)) {
    decs = dec.map(function(str) {
      if (typeof str === "string") {
        return str;
      } else {
        return registry[str];
      }
    });
  } else if (typeof dec === "string") {
    decs = [registry[dec]];
  } else {
    decs = [dec];
  }
  for (_i = 0, _len = decs.length; _i < _len; _i++) {
    dec = decs[_i];
    validate_decorator(dec);
  }
  return decs;
};

decorate = function(obj, dec, opt) {
  if (opt == null) {
    opt = {};
  }
  get_decorators(dec);
  dizen_base(obj);
  actual_merge(obj, dec);
  set_cleanup(obj, dec);
  do_init(obj, dec, opt);
  return obj;
};

flip_decorate = function(dec, opt, obj) {
  return decorate(dec, obj, opt);
};

module.exports = {
  decorate: decorate,
  flip_decorate: flip_decorate,
  use: use
};
